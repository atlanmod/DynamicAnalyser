package com.tblf.main;

import com.tblf.DotCP.DotCPParserBuilder;
import com.tblf.Link.FileTracer;
import com.tblf.classLoading.SingleURLClassLoader;
import com.tblf.instrumentation.bytecode.ByteCodeInstrumenter;
import com.tblf.parsing.ModelParser;
import com.tblf.runner.JUnitRunner;
import com.tblf.util.ModelUtils;
import org.apache.commons.io.FileUtils;
import org.eclipse.emf.ecore.resource.Resource;

import java.io.File;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.List;
import java.util.logging.Logger;
import java.util.stream.Collectors;

/**
 * Main method of the Application
 */
public class App 
{
    private static final Logger LOGGER = Logger.getAnonymousLogger();
    /**
     * Main method
     * @param args
     * args[0]: xmi model generated by MoDisco
     * args[1]: binaries folder
     * @throws MalformedURLException
     * @throws ClassNotFoundException
     */
    public static void main( String[] args ) throws Exception {
        //Checking the inputs
        if (args.length != 2) {
            LOGGER.warning("Incorrect arguments. Expecting [modelUri, binariesUri]");
            return;
        }

        File model = new File(args[0]);
        File binaries = new File(args[1]);

        if (!(model.exists() && binaries.exists())){
            LOGGER.warning("Model or Binaries don't exist");
            return;
        }

        //Loading the model
        Resource resource = null;
        if (model.toString().endsWith(".xmi")) {
            resource = ModelUtils.loadModel(model);
        } else if (model.toString().endsWith(".zip")) {
            resource = ModelUtils.loadModelFromZip(model);
        } else {
            LOGGER.warning("Incorrect model input");
            System.exit(1);
        }

        //Parsing the model
        ModelParser modelParser = new ModelParser();
        modelParser.parse(resource);

        if (modelParser.getTests().isEmpty() || modelParser.getTargets().isEmpty()) {
            LOGGER.warning("couldnt find test or SUT classes");
            return;
        }

        //Getting the dependencies from the .classpath file, assuming it is located in the same folder as the zip
        File dotCP = FileUtils.getFile(model.getParentFile(), ".classpath");
        List<File> dependencies = new DotCPParserBuilder().create().parse(dotCP);

        LOGGER.info("Adding the following dependencies to the classpath: "+dependencies.toString());

        dependencies.add(new File("libs/junit-4.12.jar"));
        dependencies.add(binaries);
        URL[] dependencyArray = dependencies.stream().map(file -> {
            URL url = null;
            try {
                url = file.toURI().toURL();
            } catch (MalformedURLException e) {

            } finally {
                return url;
            }
        }).collect(Collectors.toList()).toArray(new URL[dependencies.size()]);


        //Instrumenting the binaries
        SingleURLClassLoader.getInstance().addURLs(dependencyArray);

        ByteCodeInstrumenter byteCodeInstrumenter = new ByteCodeInstrumenter(binaries);
        byteCodeInstrumenter.instrument(modelParser.getTargets().keySet(), modelParser.getTests().keySet());

        //Running the test suites
        JUnitRunner jUnitRunner = new JUnitRunner(SingleURLClassLoader.getInstance().getUrlClassLoader());

        jUnitRunner.runTests(modelParser.getTests().keySet());

        //Analyzing the traces
        File file = ((FileTracer) FileTracer.getInstance()).getFile();
        System.out.println(file.getAbsolutePath());
    }
}
